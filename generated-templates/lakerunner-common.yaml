Conditions:
  HasApiKeysOverride: !Not
    - !Equals
      - !Ref 'ApiKeysOverride'
      - ''
  HasPublicSubnets: !Not
    - !Equals
      - !Join
        - ','
        - !Ref 'PublicSubnets'
      - ''
  HasStorageProfilesOverride: !Not
    - !Equals
      - !Ref 'StorageProfilesOverride'
      - ''
Description: CommonInfra stack for Lakerunner.
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Networking
        Parameters:
          - VpcId
          - PublicSubnets
          - PrivateSubnets
      - Label:
          default: MSK Configuration
        Parameters:
          - MSKInstanceType
          - MSKBrokerNodes
      - Label:
          default: Configuration Overrides (Advanced)
        Parameters:
          - ApiKeysOverride
          - StorageProfilesOverride
    ParameterLabels:
      ApiKeysOverride:
        default: Custom API Keys (YAML)
      MSKBrokerNodes:
        default: Number of MSK Broker Nodes
      MSKInstanceType:
        default: MSK Instance Type
      PrivateSubnets:
        default: Private Subnets (for ECS/RDS)
      PublicSubnets:
        default: Public Subnets (for ALB internet-facing)
      StorageProfilesOverride:
        default: Custom Storage Profiles (YAML)
      VpcId:
        default: VPC Id
Outputs:
  BucketArn:
    Export:
      Name: !Sub '${AWS::StackName}-BucketArn'
    Value: !GetAtt 'IngestBucket.Arn'
  BucketName:
    Export:
      Name: !Sub '${AWS::StackName}-BucketName'
    Value: !Ref 'IngestBucket'
  ClusterArn:
    Export:
      Name: !Sub '${AWS::StackName}-ClusterArn'
    Value: !GetAtt 'Cluster.Arn'
  ClusterName:
    Export:
      Name: !Sub '${AWS::StackName}-ClusterName'
    Value: !Ref 'Cluster'
  DbEndpoint:
    Export:
      Name: !Sub '${AWS::StackName}-DbEndpoint'
    Value: !GetAtt 'LakerunnerDb.Endpoint.Address'
  DbPort:
    Export:
      Name: !Sub '${AWS::StackName}-DbPort'
    Value: !GetAtt 'LakerunnerDb.Endpoint.Port'
  DbSecretArnOut:
    Export:
      Name: !Sub '${AWS::StackName}-DbSecretArn'
    Value: !Ref 'DbSecret'
  MSKClusterArn:
    Description: MSK cluster ARN
    Export:
      Name: !Sub '${AWS::StackName}-MSKClusterArn'
    Value: !GetAtt 'MSKCluster.Arn'
  MSKClusterName:
    Description: MSK cluster name
    Export:
      Name: !Sub '${AWS::StackName}-MSKClusterName'
    Value: !Ref 'MSKCluster'
  MSKCredentialsArn:
    Description: MSK SASL/SCRAM credentials secret ARN
    Export:
      Name: !Sub '${AWS::StackName}-MSKCredentialsArn'
    Value: !Ref 'MSKCredentials'
  MSKSecretsKeyArn:
    Description: KMS key ARN for MSK secrets encryption
    Export:
      Name: !Sub '${AWS::StackName}-MSKSecretsKeyArn'
    Value: !GetAtt 'MSKSecretsKey.Arn'
  MSKSecurityGroupId:
    Description: MSK security group ID for granting access from ECS/EKS
    Export:
      Name: !Sub '${AWS::StackName}-MSKSecurityGroupId'
    Value: !Ref 'MSKSecurityGroup'
  PrivateSubnetsOut:
    Export:
      Name: !Sub '${AWS::StackName}-PrivateSubnets'
    Value: !Sub
      - ${Subnet1},${Subnet2}
      - Subnet1: !Select
          - 0
          - !Ref 'PrivateSubnets'
        Subnet2: !Select
          - 1
          - !Ref 'PrivateSubnets'
  PublicSubnetsOut:
    Export:
      Name: !Sub '${AWS::StackName}-PublicSubnets'
    Value: !If
      - HasPublicSubnets
      - !Join
        - ','
        - !Ref 'PublicSubnets'
      - ''
  SupportsInternetFacingAlb:
    Description: Whether this CommonInfra stack supports internet-facing ALBs (requires PublicSubnets)
    Export:
      Name: !Sub '${AWS::StackName}-SupportsInternetFacingAlb'
    Value: !If
      - HasPublicSubnets
      - 'Yes'
      - 'No'
  TaskSecurityGroupId:
    Export:
      Name: !Sub '${AWS::StackName}-TaskSGId'
    Value: !Ref 'TaskSG'
  VpcIdOut:
    Export:
      Name: !Sub '${AWS::StackName}-VpcId'
    Value: !Ref 'VpcId'
Parameters:
  ApiKeysOverride:
    Default: ''
    Description: 'OPTIONAL: Custom API keys configuration in YAML format. Leave blank to use defaults from defaults.yaml. Example: - organization_id: xxx\n  keys:\n    - keyvalue'
    Type: String
  MSKBrokerNodes:
    Default: 2
    Description: Number of MSK broker nodes. Must be between 2 and 15.
    MaxValue: 15
    MinValue: 2
    Type: Number
  MSKInstanceType:
    AllowedValues:
      - kafka.t3.small
      - kafka.m5.large
      - kafka.m5.xlarge
      - kafka.m5.2xlarge
      - kafka.m5.4xlarge
      - kafka.m5.8xlarge
      - kafka.m5.12xlarge
      - kafka.m5.16xlarge
      - kafka.m5.24xlarge
      - kafka.m7g.large
      - kafka.m7g.xlarge
      - kafka.m7g.2xlarge
      - kafka.m7g.4xlarge
      - kafka.m7g.8xlarge
      - kafka.m7g.12xlarge
      - kafka.m7g.16xlarge
    Default: kafka.t3.small
    Description: MSK broker instance type.
    Type: String
  PrivateSubnets:
    Description: 'REQUIRED: Private subnet IDs (for RDS/ECS). Provide at least two in different AZs.'
    Type: List<AWS::EC2::Subnet::Id>
  PublicSubnets:
    Default: ''
    Description: Public subnet IDs (for internet-facing ALB). Required when ALB uses internet-facing scheme. Provide at least two in different AZs.
    Type: List<AWS::EC2::Subnet::Id>
  StorageProfilesOverride:
    Default: ''
    Description: 'OPTIONAL: Custom storage profiles configuration in YAML format. Leave blank to use defaults from defaults.yaml. Bucket name and region will be auto-filled.'
    Type: String
  VpcId:
    Description: 'REQUIRED: VPC where resources will be created.'
    Type: AWS::EC2::VPC::Id
Resources:
  ApiKeysParam:
    Properties:
      Description: API keys configuration
      Name: /lakerunner/api_keys
      Type: String
      Value: !If
        - HasApiKeysOverride
        - !Ref 'ApiKeysOverride'
        - "- keys:\n  - f70603aa00e6f67999cc66e336134887\n  organization_id: 12340000-0000-4000-8000-000000000000\n"
    Type: AWS::SSM::Parameter
  Cluster:
    Properties:
      ClusterName: !Sub '${AWS::StackName}-cluster'
      Tags:
        - Key: Component
          Value: Compute
        - Key: Environment
          Value: !Ref 'AWS::StackName'
        - Key: ManagedBy
          Value: Lakerunner
        - Key: Name
          Value: !Sub '${AWS::StackName}-cluster'
    Type: AWS::ECS::Cluster
  DbSecret:
    Properties:
      GenerateSecretString:
        ExcludePunctuation: true
        GenerateStringKey: password
        SecretStringTemplate: '{"username":"lakerunner"}'
    Type: AWS::SecretsManager::Secret
  DbSubnetGroup:
    Properties:
      DBSubnetGroupDescription: DB subnets
      SubnetIds: !Ref 'PrivateSubnets'
    Type: AWS::RDS::DBSubnetGroup
  IngestBucket:
    DeletionPolicy: Delete
    Properties:
      LifecycleConfiguration:
        Rules:
          - ExpirationInDays: 10
            Prefix: otel-raw/
            Status: Enabled
      NotificationConfiguration:
        QueueConfigurations:
          - Event: s3:ObjectCreated:*
            Filter:
              S3Key:
                Rules:
                  - Name: prefix
                    Value: otel-raw/
            Queue: !GetAtt 'IngestQueue.Arn'
          - Event: s3:ObjectCreated:*
            Filter:
              S3Key:
                Rules:
                  - Name: prefix
                    Value: logs-raw/
            Queue: !GetAtt 'IngestQueue.Arn'
          - Event: s3:ObjectCreated:*
            Filter:
              S3Key:
                Rules:
                  - Name: prefix
                    Value: metrics-raw/
            Queue: !GetAtt 'IngestQueue.Arn'
      Tags:
        - Key: Component
          Value: Storage
        - Key: Environment
          Value: !Ref 'AWS::StackName'
        - Key: ManagedBy
          Value: Lakerunner
        - Key: Name
          Value: !Sub '${AWS::StackName}-ingest-bucket'
    Type: AWS::S3::Bucket
  IngestQueue:
    Properties:
      MessageRetentionPeriod: 345600
      QueueName: lakerunner-ingest-queue
      Tags:
        - Key: Component
          Value: Messaging
        - Key: Environment
          Value: !Ref 'AWS::StackName'
        - Key: ManagedBy
          Value: Lakerunner
        - Key: Name
          Value: !Sub '${AWS::StackName}-ingest-queue'
    Type: AWS::SQS::Queue
  IngestQueuePolicy:
    Properties:
      PolicyDocument:
        Statement:
          - Action:
              - sqs:GetQueueAttributes
              - sqs:GetQueueUrl
              - sqs:SendMessage
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref 'AWS::AccountId'
            Effect: Allow
            Principal:
              Service: s3.amazonaws.com
            Resource: !GetAtt 'IngestQueue.Arn'
        Version: '2012-10-17'
      Queues:
        - !Ref 'IngestQueue'
    Type: AWS::SQS::QueuePolicy
  LakerunnerDb:
    Properties:
      AllocatedStorage: '100'
      CopyTagsToSnapshot: true
      DBInstanceClass: db.t3.medium
      DBName: lakerunner
      DBSubnetGroupName: !Ref 'DbSubnetGroup'
      DeletionProtection: false
      Engine: postgres
      EngineVersion: '17'
      MasterUserPassword: !Sub
        - '{{resolve:secretsmanager:${S}:SecretString:password}}'
        - S: !Ref 'DbSecret'
      MasterUsername: !Sub
        - '{{resolve:secretsmanager:${S}:SecretString:username}}'
        - S: !Ref 'DbSecret'
      MultiAZ: false
      PubliclyAccessible: false
      StorageType: gp3
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-database'
        - Key: ManagedBy
          Value: Lakerunner
        - Key: Environment
          Value: !Ref 'AWS::StackName'
        - Key: Component
          Value: Database
      VPCSecurityGroups:
        - !Ref 'TaskSG'
    Type: AWS::RDS::DBInstance
  MSKCluster:
    Properties:
      BrokerNodeGroupInfo:
        ClientSubnets: !Ref 'PrivateSubnets'
        InstanceType: !Ref 'MSKInstanceType'
        SecurityGroups:
          - !Ref 'MSKSecurityGroup'
        StorageInfo:
          EBSStorageInfo:
            VolumeSize: 100
      ClientAuthentication:
        Sasl:
          Scram:
            Enabled: true
      ClusterName: !Sub '${AWS::StackName}-msk-cluster'
      EncryptionInfo:
        EncryptionInTransit:
          ClientBroker: TLS
          InCluster: true
      KafkaVersion: 3.9.x
      NumberOfBrokerNodes: !Ref 'MSKBrokerNodes'
      Tags:
        Component: Messaging
        Environment: !Ref 'AWS::StackName'
        ManagedBy: Lakerunner
        Name: !Sub '${AWS::StackName}-msk-cluster'
    Type: AWS::MSK::Cluster
  MSKCredentials:
    Properties:
      Description: MSK SASL/SCRAM credentials for Kafka authentication
      GenerateSecretString:
        ExcludeCharacters: '"@/\'
        GenerateStringKey: password
        PasswordLength: 32
        SecretStringTemplate: '{"username": "lakerunner"}'
      KmsKeyId: !Ref 'MSKSecretsKey'
      Name: !Sub 'AmazonMSK_${AWS::StackName}'
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-msk-credentials'
        - Key: ManagedBy
          Value: Lakerunner
        - Key: Environment
          Value: !Ref 'AWS::StackName'
        - Key: Component
          Value: Messaging
    Type: AWS::SecretsManager::Secret
  MSKFromTasksSG:
    Properties:
      Description: Kafka TLS from ECS tasks
      FromPort: 9094
      GroupId: !Ref 'MSKSecurityGroup'
      IpProtocol: tcp
      SourceSecurityGroupId: !Ref 'TaskSG'
      ToPort: 9094
    Type: AWS::EC2::SecurityGroupIngress
  MSKFromTasksSGSASL:
    Properties:
      Description: Kafka SASL_SSL from ECS tasks
      FromPort: 9096
      GroupId: !Ref 'MSKSecurityGroup'
      IpProtocol: tcp
      SourceSecurityGroupId: !Ref 'TaskSG'
      ToPort: 9096
    Type: AWS::EC2::SecurityGroupIngress
  MSKScramAssociation:
    DependsOn:
      - MSKCluster
      - MSKCredentials
    Properties:
      ClusterArn: !GetAtt 'MSKCluster.Arn'
      SecretArnList:
        - !Ref 'MSKCredentials'
      ServiceToken: !GetAtt 'MSKScramAssociationFunction.Arn'
    Type: AWS::CloudFormation::CustomResource
  MSKScramAssociationFunction:
    Properties:
      Code:
        ZipFile: |2

          import json
          import boto3
          import urllib.request

          def send_response(event, context, status, data=None, reason=""):
              body = json.dumps({
                  "Status": status,
                  "Reason": reason or f"See CloudWatch Log: {context.log_stream_name}",
                  "PhysicalResourceId": event.get("PhysicalResourceId", "MSKScramAssoc"),
                  "StackId": event["StackId"],
                  "RequestId": event["RequestId"],
                  "LogicalResourceId": event["LogicalResourceId"],
                  "Data": data or {}
              }).encode()
              req = urllib.request.Request(event["ResponseURL"], data=body, method="PUT")
              req.add_header("content-type", "")
              req.add_header("content-length", str(len(body)))
              urllib.request.urlopen(req).read()

          def handler(event, context):
              print(f"Event: {json.dumps(event)}")
              try:
                  props = event.get("ResourceProperties", {})
                  cluster_arn = props["ClusterArn"]
                  secret_arns = props["SecretArnList"]
                  kafka = boto3.client("kafka")

                  if event["RequestType"] == "Delete":
                      try:
                          kafka.batch_disassociate_scram_secret(
                              ClusterArn=cluster_arn, SecretArnList=secret_arns)
                      except Exception as e:
                          print(f"Disassociate error (ignored): {e}")
                      send_response(event, context, "SUCCESS")
                      return

                  # Associate secrets (idempotent - safe to call even if already associated)
                  result = kafka.batch_associate_scram_secret(
                      ClusterArn=cluster_arn, SecretArnList=secret_arns)
                  if result.get("UnprocessedScramSecrets"):
                      errors = [s.get("ErrorMessage", "Unknown") for s in result["UnprocessedScramSecrets"]]
                      raise Exception(f"Failed to associate: {errors}")
                  print("Successfully associated SCRAM secrets")
                  send_response(event, context, "SUCCESS", {"Message": "Associated"})
              except Exception as e:
                  print(f"Error: {e}")
                  send_response(event, context, "FAILED", reason=str(e))
      FunctionName: !Sub '${AWS::StackName}-msk-scram-assoc'
      Handler: index.handler
      Role: !GetAtt 'MSKScramAssociationRole.Arn'
      Runtime: python3.12
      Timeout: 60
    Type: AWS::Lambda::Function
  MSKScramAssociationRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - kafka:BatchAssociateScramSecret
                  - kafka:BatchDisassociateScramSecret
                Effect: Allow
                Resource: !GetAtt 'MSKCluster.Arn'
              - Action:
                  - secretsmanager:GetSecretValue
                Effect: Allow
                Resource: !Ref 'MSKCredentials'
              - Action:
                  - kms:Decrypt
                  - kms:GenerateDataKey
                  - kms:CreateGrant
                  - kms:DescribeKey
                Effect: Allow
                Resource: !GetAtt 'MSKSecretsKey.Arn'
            Version: '2012-10-17'
          PolicyName: MSKScramPolicy
    Type: AWS::IAM::Role
  MSKSecretsKey:
    Properties:
      Description: KMS key for MSK SASL/SCRAM secrets
      KeyPolicy:
        Statement:
          - Action: kms:*
            Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:root'
            Resource: '*'
            Sid: Enable IAM User Permissions
          - Action:
              - kms:Decrypt
              - kms:GenerateDataKey
            Effect: Allow
            Principal:
              Service: kafka.amazonaws.com
            Resource: '*'
            Sid: Allow MSK Service
          - Action:
              - kms:Decrypt
              - kms:GenerateDataKey
              - kms:ReEncrypt*
            Effect: Allow
            Principal:
              Service: secretsmanager.amazonaws.com
            Resource: '*'
            Sid: Allow Secrets Manager
        Version: '2012-10-17'
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-msk-secrets-key'
        - Key: ManagedBy
          Value: Lakerunner
        - Key: Environment
          Value: !Ref 'AWS::StackName'
        - Key: Component
          Value: Messaging
    Type: AWS::KMS::Key
  MSKSecretsKeyAlias:
    Properties:
      AliasName: !Sub 'alias/${AWS::StackName}-msk-secrets'
      TargetKeyId: !Ref 'MSKSecretsKey'
    Type: AWS::KMS::Alias
  MSKSecurityGroup:
    Properties:
      GroupDescription: Security group for MSK cluster - grant access by referencing this SG ID
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-msk-sg'
        - Key: ManagedBy
          Value: Lakerunner
        - Key: Environment
          Value: !Ref 'AWS::StackName'
        - Key: Component
          Value: Messaging
      VpcId: !Ref 'VpcId'
    Type: AWS::EC2::SecurityGroup
  StorageProfilesParam:
    Properties:
      Description: Storage profiles configuration
      Name: /lakerunner/storage_profiles
      Type: String
      Value: !If
        - HasStorageProfilesOverride
        - !Ref 'StorageProfilesOverride'
        - !Sub
          - "- bucket: ${Bucket}\n  cloud_provider: aws\n  collector_name: lakerunner\n  insecure_tls: false\n  instance_num: 1\n  organization_id: 12340000-0000-4000-8000-000000000000\n  region: ${AWS::Region}\n\
            \  use_path_style: true\n"
          - Bucket: !Ref 'IngestBucket'
    Type: AWS::SSM::Parameter
  TaskSG:
    Properties:
      GroupDescription: Security group for ECS tasks
      SecurityGroupEgress:
        - CidrIp: '0.0.0.0/0'
          Description: Allow all outbound
          IpProtocol: '-1'
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-task-sg'
        - Key: ManagedBy
          Value: Lakerunner
        - Key: Environment
          Value: !Ref 'AWS::StackName'
        - Key: Component
          Value: Compute
      VpcId: !Ref 'VpcId'
    Type: AWS::EC2::SecurityGroup
  TaskSG7101Self:
    Properties:
      Description: task-to-task 7101
      FromPort: 7101
      GroupId: !Ref 'TaskSG'
      IpProtocol: tcp
      SourceSecurityGroupId: !Ref 'TaskSG'
      ToPort: 7101
    Type: AWS::EC2::SecurityGroupIngress
  TaskSG8081Self:
    Properties:
      Description: task-to-task 8081 (query-api to query-worker)
      FromPort: 8081
      GroupId: !Ref 'TaskSG'
      IpProtocol: tcp
      SourceSecurityGroupId: !Ref 'TaskSG'
      ToPort: 8081
    Type: AWS::EC2::SecurityGroupIngress
  TaskSGDbSelf:
    Properties:
      Description: task-to-database PostgreSQL
      FromPort: 5432
      GroupId: !Ref 'TaskSG'
      IpProtocol: tcp
      SourceSecurityGroupId: !Ref 'TaskSG'
      ToPort: 5432
    Type: AWS::EC2::SecurityGroupIngress

