Description: 'Lakerunner DB migration (single template): defines TaskDefinition and runs it via Custom Resource.'
Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: CommonInfra Stack
        Parameters:
          - CommonInfraStackName
      - Label:
          default: Task Sizing
        Parameters:
          - Cpu
          - MemoryMiB
      - Label:
          default: Container Image
        Parameters:
          - ContainerImage
    ParameterLabels:
      CommonInfraStackName:
        default: CommonInfra Stack Name
      ContainerImage:
        default: Migration Image
      Cpu:
        default: Fargate CPU
      MemoryMiB:
        default: Fargate Memory (MiB)
Outputs:
  LogGroupName:
    Export:
      Name: !Sub '${AWS::StackName}-LogGroup'
    Value: !Ref 'MigrationLogGroup'
  RunMigrationId:
    Export:
      Name: !Sub '${AWS::StackName}-RunMigrationId'
    Value: !Ref 'RunMigration'
  RunnerFunctionArn:
    Export:
      Name: !Sub '${AWS::StackName}-RunnerFnArn'
    Value: !GetAtt 'RunEcsTaskFunction.Arn'
  TaskDefinitionArn:
    Export:
      Name: !Sub '${AWS::StackName}-TaskDefinitionArn'
    Value: !GetAtt 'MigrationTaskDef.TaskDefinitionArn'
Parameters:
  CommonInfraStackName:
    Default: ''
    Description: 'REQUIRED: Name of the CommonInfra stack to import values from.'
    Type: String
  ContainerImage:
    Default: public.ecr.aws/cardinalhq.io/lakerunner:latest
    Description: Migration container image.
    Type: String
  Cpu:
    Default: '512'
    Description: Fargate CPU units (e.g., 256/512/1024).
    Type: String
  MemoryMiB:
    Default: '1024'
    Description: Fargate Memory MiB (e.g., 512/1024/2048).
    Type: String
Resources:
  MigrationLogGroup:
    Properties:
      LogGroupName: !Sub '/lakerunner/migration/${AWS::StackName}'
      RetentionInDays: 14
    Type: AWS::Logs::LogGroup
  MigrationTaskDef:
    Properties:
      ContainerDefinitions:
        - Command:
            - /app/bin/lakerunner
            - migrate
          Environment:
            - Name: LRDB_HOST
              Value: !ImportValue
                Fn::Sub: ${CommonInfraStackName}-DbEndpoint
            - Name: LRDB_PORT
              Value: '5432'
            - Name: LRDB_NAME
              Value: lakerunner
            - Name: LRDB_USER
              Value: lakerunner
            - Name: LRDB_SSLMODE
              Value: require
          Image: !Ref 'ContainerImage'
          LogConfiguration:
            LogDriver: awslogs
            Options:
              awslogs-group: !Ref 'MigrationLogGroup'
              awslogs-region: !Sub '${AWS::Region}'
              awslogs-stream-prefix: migration
          Name: Migrator
          Secrets:
            - Name: LRDB_PASSWORD
              ValueFrom: !Sub
                - '${S}:password::'
                - S: !ImportValue
                    Fn::Sub: ${CommonInfraStackName}-DbSecretArn
      Cpu: !Ref 'Cpu'
      ExecutionRoleArn: !GetAtt 'TaskExecutionRole.Arn'
      Family: lakerunner-migration
      Memory: !Ref 'MemoryMiB'
      NetworkMode: awsvpc
      RequiresCompatibilities:
        - FARGATE
      TaskRoleArn: !GetAtt 'MigrationTaskRole.Arn'
    Type: AWS::ECS::TaskDefinition
  MigrationTaskRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
        Version: '2012-10-17'
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - secretsmanager:GetSecretValue
                Effect: Allow
                Resource:
                  - !ImportValue
                    Fn::Sub: ${CommonInfraStackName}-DbSecretArn
            Version: '2012-10-17'
          PolicyName: MigrationTaskPolicy
    Type: AWS::IAM::Role
  RunEcsTaskFunction:
    Properties:
      Code:
        ZipFile: |2

          import json, time, urllib.request, boto3

          ecs = boto3.client("ecs")

          def send(event, context, status, data=None, reason=""):
              resp = {
                  "Status": status,
                  "Reason": f"{reason} See CloudWatch Logs for details: {context.log_stream_name}",
                  "PhysicalResourceId": event.get("PhysicalResourceId") or "RunEcsTask",
                  "StackId": event["StackId"],
                  "RequestId": event["RequestId"],
                  "LogicalResourceId": event["LogicalResourceId"],
                  "NoEcho": False,
                  "Data": data or {}
              }
              body = json.dumps(resp).encode("utf-8")
              req = urllib.request.Request(event["ResponseURL"], data=body, method="PUT")
              req.add_header("content-type","")
              req.add_header("content-length", str(len(body)))
              try:
                  with urllib.request.urlopen(req) as r:
                      r.read()
              except Exception as e:
                  print("Failed to send response:", e)

          def handler(event, context):
              print("Event:", json.dumps(event))
              reqtype = event["RequestType"]
              props = event.get("ResourceProperties", {})

              if reqtype == "Delete":
                  send(event, context, "SUCCESS", {"Message":"Delete no-op"})
                  return

              cluster = props["ClusterArn"]
              taskdef = props["TaskDefinitionArn"]
              subnets = props["Subnets"]
              sgs = props["SecurityGroups"]
              assign = props.get("AssignPublicIp","DISABLED")

              try:
                  run = ecs.run_task(
                      cluster=cluster,
                      taskDefinition=taskdef,
                      launchType="FARGATE",
                      platformVersion="LATEST",
                      networkConfiguration={
                          "awsvpcConfiguration": {
                              "subnets": subnets,
                              "securityGroups": sgs,
                              "assignPublicIp": assign
                          }
                      },
                      count=1
                  )
                  failures = run.get("failures",[])
                  if failures:
                      reason = "; ".join(f.get("reason","unknown") for f in failures)
                      send(event, context, "FAILED", {"RunFailures": failures}, reason=f"RunTask failures: {reason}")
                      return

                  tasks = run.get("tasks", [])
                  if not tasks:
                      send(event, context, "FAILED", {"Message":"ecs.run_task returned no tasks"}, reason="No task started")
                      return

                  task_arn = tasks[0]["taskArn"]
                  print("Started task:", task_arn)

                  deadline = time.time() + 14*60
                  last_status = None
                  while time.time() < deadline:
                      d = ecs.describe_tasks(cluster=cluster, tasks=[task_arn])
                      ts = d.get("tasks", [])
                      if not ts:
                          send(event, context, "FAILED", {"Message":"Task disappeared"}, reason="DescribeTasks returned no tasks")
                          return
                      t = ts[0]
                      last_status = t.get("lastStatus","UNKNOWN")
                      print("Status:", last_status)
                      if last_status == "STOPPED":
                          bad = []
                          for c in t.get("containers",[]):
                              code = c.get("exitCode")
                              name = c.get("name")
                              if code is None or code != 0:
                                  bad.append({"name": name, "exitCode": code})
                          if bad:
                              send(event, context, "FAILED",
                                   {"TaskArn": task_arn, "StoppedReason": t.get("stoppedReason"), "BadContainers": bad},
                                   reason=f"Container(s) non-zero exit: {bad}")
                              return
                          send(event, context, "SUCCESS",
                               {"TaskArn": task_arn, "StoppedReason": t.get("stoppedReason","")})
                          return
                      time.sleep(6)

                  send(event, context, "FAILED", {"TaskArn": task_arn, "LastStatus": last_status}, reason="Timeout waiting for STOPPED")

              except Exception as e:
                  print("Exception:", e)
                  send(event, context, "FAILED", {"Error": str(e)}, reason=str(e))
      Handler: index.handler
      Role: !GetAtt 'RunnerLambdaRole.Arn'
      Runtime: python3.13
      Timeout: 900
    Type: AWS::Lambda::Function
  RunMigration:
    Properties:
      AssignPublicIp: DISABLED
      ClusterArn: !ImportValue
        Fn::Sub: ${CommonInfraStackName}-ClusterArn
      SecurityGroups:
        - !ImportValue
          Fn::Sub: ${CommonInfraStackName}-TaskSGId
      ServiceToken: !GetAtt 'RunEcsTaskFunction.Arn'
      Subnets: !Split
        - ','
        - !ImportValue
          Fn::Sub: ${CommonInfraStackName}-PrivateSubnets
      TaskDefinitionArn: !GetAtt 'MigrationTaskDef.TaskDefinitionArn'
    Type: Custom::RunEcsTask
  RunnerLambdaRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
        Version: '2012-10-17'
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Effect: Allow
                Resource: '*'
              - Action:
                  - ecs:RunTask
                  - ecs:DescribeTasks
                Effect: Allow
                Resource: '*'
              - Action:
                  - iam:PassRole
                Effect: Allow
                Resource:
                  - !GetAtt 'MigrationTaskRole.Arn'
                  - !GetAtt 'TaskExecutionRole.Arn'
            Version: '2012-10-17'
          PolicyName: RunnerInlinePolicy
    Type: AWS::IAM::Role
  TaskExecutionRole:
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Action: sts:AssumeRole
            Effect: Allow
            Principal:
              Service: ecs-tasks.amazonaws.com
        Version: '2012-10-17'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
      Policies:
        - PolicyDocument:
            Statement:
              - Action:
                  - secretsmanager:GetSecretValue
                Effect: Allow
                Resource:
                  - !ImportValue
                    Fn::Sub: ${CommonInfraStackName}-DbSecretArn
            Version: '2012-10-17'
          PolicyName: TaskExecutionSecretsPolicy
    Type: AWS::IAM::Role

